<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Makefile Learning</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="学习写Makefile">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">ABOUT Assembly</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="docs/index.html"><strong aria-hidden="true">1.</strong> Knowledge</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/1.html"><strong aria-hidden="true">1.1.</strong> 基本内容</a></li><li class="chapter-item expanded "><a href="docs/2.html"><strong aria-hidden="true">1.2.</strong> 书写规则</a></li><li class="chapter-item expanded "><a href="docs/3.html"><strong aria-hidden="true">1.3.</strong> 命令</a></li><li class="chapter-item expanded "><a href="docs/4.html"><strong aria-hidden="true">1.4.</strong> 条件</a></li><li class="chapter-item expanded "><a href="docs/5.html"><strong aria-hidden="true">1.5.</strong> 其他</a></li></ol></li><li class="chapter-item expanded "><a href="labs/index.html"><strong aria-hidden="true">2.</strong> Labs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="labs/NKU-compiler.html"><strong aria-hidden="true">2.1.</strong> 简单makefile分析</a></li><li class="chapter-item expanded "><a href="labs/ucore.html"><strong aria-hidden="true">2.2.</strong> 中等makefile分析</a></li><li class="chapter-item expanded "><a href="labs/ucore-rv.html"><strong aria-hidden="true">2.3.</strong> 另一个中等makefile分析</a></li><li class="chapter-item expanded "><a href="labs/optee.html"><strong aria-hidden="true">2.4.</strong> 复杂makefile分析</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Makefile Learning</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/TephrocactusMYC/Makefile-Learning" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="跟我一起写makefile"><a class="header" href="#跟我一起写makefile">《跟我一起写Makefile》</a></h1>
<p>主要记录读书笔记和针对一些项目里的Makefile的分析</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="笔记"><a class="header" href="#笔记">笔记</a></h1>
<p>详细记录我认为有价值和重要的知识点</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>makefile关系到了整个工程的编译规则。
&gt;一个工程中的源文件不计其数，并且按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p>
<p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<h2 id="关于程序的编译和链接"><a class="header" href="#关于程序的编译和链接">关于程序的编译和链接</a></h2>
<blockquote>
<p>一般来说，无论是C还是C++，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成可执行文件，这个动作叫作链接（link）。</p>
</blockquote>
<blockquote>
<p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（ .o 文件或 .obj 文件）。</p>
</blockquote>
<blockquote>
<p>链接时，主要是链接函数和全局变量。所以，我们可以使用这些中间目标文件（ .o 文件或 .obj 文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File），也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p>
</blockquote>
<h2 id="makefile-基础"><a class="header" href="#makefile-基础">makefile 基础</a></h2>
<h3 id="从例子开始"><a class="header" href="#从例子开始">从例子开始</a></h3>
<p>我们的规则是：</p>
<ul>
<li>如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。</li>
<li>如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</li>
</ul>
<h3 id="makefile的规则"><a class="header" href="#makefile的规则">makefile的规则</a></h3>
<pre><code>target ... : prerequisites ...
    recipe
    ...
    ...
</code></pre>
<h4 id="target"><a class="header" href="#target">target</a></h4>
<p>可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p>
<h4 id="prerequisites"><a class="header" href="#prerequisites">prerequisites</a></h4>
<p>生成该target所依赖的文件和/或target。</p>
<h4 id="recipe"><a class="header" href="#recipe">recipe</a></h4>
<p>该target要执行的命令（任意的shell命令）。</p>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:</p>
<p><strong>prerequisites中如果有一个以上的文件比target文件要新的话，recipe所定义的命令就会被执行。</strong>
这就是makefile的规则，也就是makefile中最核心的内容。</p>
<p>make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<h3 id="make是如何工作的"><a class="header" href="#make是如何工作的">make是如何工作的</a></h3>
<p>在默认的方式下，也就是我们只输入 make 命令。那么，</p>
<ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。</li>
<li>如果 edit 所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和头文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生成make的终极任务，也就是可执行文件 edit 了。</li>
</ol>
<h3 id="makefile中使用变量"><a class="header" href="#makefile中使用变量">makefile中使用变量</a></h3>
<p>在一开始生命，然后使用</p>
<pre><code>$(变量名)
</code></pre>
<p>即可方便维护</p>
<h3 id="让make自动推导"><a class="header" href="#让make自动推导">让make自动推导</a></h3>
<p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 .o 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果make找到一个 whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来</p>
<p><strong>还可以更加简洁，根据依赖来合并，但是不易维护了</strong></p>
<h3 id="清空目录的规则"><a class="header" href="#清空目录的规则">清空目录的规则</a></h3>
<p>每个Makefile中都应该写一个清空目标文件（ .o ）和可执行文件的规则，这不仅便于重编译，也很利于保持文件的清洁。</p>
<p>.PHONY 表示 clean 是一个“伪目标”</p>
<p>而在 rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， clean 的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。</p>
<h3 id="makefile里有什么"><a class="header" href="#makefile里有什么">Makefile里有什么？</a></h3>
<p>Makefile里主要包含了五个东西：显式规则、隐式规则、变量定义、指令和注释。</p>
<ol>
<li>显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li>
<li>隐式规则。由于我们的make有自动推导的功能，所以隐式规则可以让我们比较简略地书写Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>指令。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 # 字符，这个就像C/C++中的 // 一样。如果你要在你的Makefile中使用 # 字符，可以用反斜杠进行转义，如： # 。</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以 Tab 键开始。</p>
<h3 id="makefile的文件名"><a class="header" href="#makefile的文件名">Makefile的文件名</a></h3>
<p>默认的情况下，make命令会在当前目录下按顺序寻找文件名为 GNUmakefile 、 makefile 和 Makefile 的文件。在这三个文件名中，最好使用 <code>Makefile</code> 这个文件名，因为这个文件名在排序上靠近其它比较重要的文件，比如 README。最好不要用 GNUmakefile，因为这个文件名只能由GNU make ，其它版本的 make 无法识别，但是基本上来说，大多数的 make 都支持 makefile 和 Makefile 这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Solaris”，“Make.Linux”等，如果要指定特定的Makefile，你可以使用make的 -f 或 –file 参数，如： make -f Make.Solaris 或 make –file Make.Linux 。如果你使用多条 -f 或 –file 参数，你可以指定多个makefile。</p>
<h3 id="包含其它makefile"><a class="header" href="#包含其它makefile">包含其它Makefile</a></h3>
<p>在Makefile使用 include 指令可以把别的Makefile包含进来，这很像C语言的 #include ，被包含的文件会原模原样的放在当前文件的包含位置。 include 的语法是：</p>
<pre><code>include &lt;filenames&gt;...
</code></pre>
<p><code>&lt;filenames&gt;</code> 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。</p>
<p>make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的 #include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<p>如果make执行时，有 -I 或 –include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。</p>
<p>接下来按顺序寻找目录 <prefix>/include （一般是 /usr/local/bin ）、 /usr/gnu/include 、 /usr/local/include 、 /usr/include 。</p>
<p><strong>环境变量 .INCLUDE_DIRS 包含当前 make 会寻找的目录列表。你应当避免使用命令行参数 -I 来寻找以上这些默认目录，否则会使得 make “忘掉”所有已经设定的包含目录，包括默认目录。</strong></p>
<h3 id="make的工作方式"><a class="header" href="#make的工作方式">make的工作方式</a></h3>
<p>GNU的make工作时的执行步骤如下：（想来其它的make也是类似）</p>
<ol>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐式规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="书写规则"><a class="header" href="#书写规则">书写规则</a></h1>
<h2 id="通配符相关"><a class="header" href="#通配符相关">通配符相关</a></h2>
<p><code>objects = *.o</code>
上面这个例子，表示了通配符同样可以用在变量中。并不是说 *.o 会展开，不！objects的值就是 *.o 。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有 .o 的文件名的集合，那么，你可以这样：</p>
<p><code>objects := $(wildcard *.o)</code>
另给一个变量使用通配符的例子：</p>
<ol>
<li>列出一确定文件夹中的所有 .c 文件。</li>
</ol>
<p><code>objects := $(wildcard *.c)</code>
2. 列出(1)中所有文件对应的 .o 文件，在（3）中我们可以看到它是由make自动编译出的:</p>
<p><code>$(patsubst %.c,%.o,$(wildcard *.c))</code>
3. 由(1)(2)两步，可写出编译并链接所有 .c 和 .o 文件</p>
<pre><code>objects := $(patsubst %.c,%.o,$(wildcard *.c))
foo : $(objects)
    cc -o foo $(objects)
</code></pre>
<p>这种用法由关键字“wildcard”，“patsubst”指出</p>
<h2 id="文件搜寻"><a class="header" href="#文件搜寻">文件搜寻</a></h2>
<p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p>
<p>Makefile文件中的特殊变量 VPATH 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<p><code>VPATH = src:../headers</code>
上面的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p>
<p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<p><code>vpath &lt;pattern&gt; &lt;directories&gt;</code>
为符合模式<pattern>的文件指定搜索目录<directories>。</p>
<p><code>vpath &lt;pattern&gt;</code>
清除符合模式<pattern>的文件的搜索目录。</p>
<p><code>vpath</code>
清除所有已被设置好了的文件搜索目录。</p>
<p>vpath使用方法中的<pattern>需要包含 % 字符。 % 的意思是匹配零或若干字符，（需引用 % ，使用 \ ）例如， %.h 表示所有以 .h 结尾的文件。<pattern>指定了要搜索的文件集，而<directories>则指定了&lt; pattern&gt;的文件集的搜索的目录。例如：</p>
<p><code>vpath %.h ../headers</code>
该语句表示，要求make在“../headers”目录下搜索所有以 .h 结尾的文件。（如果某文件在当前目录没有找到的话）</p>
<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的<pattern> ，或是被重复了的<pattern>，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>
<pre><code>vpath %.c foo
vpath %   blish
vpath %.c bar
</code></pre>
<p>其表示 .c 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</p>
<pre><code>vpath %.c foo:bar
vpath %   blish
</code></pre>
<p>而上面的语句则表示 .c 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<h2 id="伪目标"><a class="header" href="#伪目标">伪目标</a></h2>
<p>“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<p><code>.PHONY : clean</code>
只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：</p>
<pre><code>.PHONY : clean
clean :
    rm *.o temp
</code></pre>
<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<pre><code>all : prog1 prog2 prog3
.PHONY : all

prog1 : prog1.o utils.o
    cc -o prog1 prog1.o utils.o

prog2 : prog2.o
    cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o
</code></pre>
<h2 id="多目标"><a class="header" href="#多目标">多目标</a></h2>
<p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 $@ （关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>
<pre><code>bigoutput littleoutput : text.g
    generate text.g -$(subst output,,$@) &gt; $@
</code></pre>
<p>上述规则等价于：</p>
<pre><code>bigoutput : text.g
    generate text.g -big &gt; bigoutput
littleoutput : text.g
    generate text.g -little &gt; littleoutput
</code></pre>
<p>其中， -$(subst output,,$@) 中的 $ 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， $@ 表示目标的集合，就像一个数组， $@ 依次取出目标，并执于命令。</p>
<h2 id="静态模式"><a class="header" href="#静态模式">静态模式</a></h2>
<p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>
<pre><code>&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;
    &lt;commands&gt;
    ...
</code></pre>
<p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
<p>target-pattern是指明了targets的模式，也就是的目标集模式。</p>
<p>prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</p>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-pattern>定义成 %.o ，意思是我们的<target>;集合中都是以 .o 结尾的，而如果我们的<prereq-patterns>定义成 %.c ，意思是对<target-pattern>所形成的目标集进行二次定义，其计算方法是，取<target-pattern>模式中的 % （也就是去掉了 .o 这个结尾），并为其加上 .c 这个结尾，形成的新集合。</p>
<p>所以，我们的“目标模式”或是“依赖模式”中都应该有 % 这个字符，如果你的文件名中有 % 那么你可以使用反斜杠 \ 进行转义，来标明真实的 % 字符。</p>
<p>看一个例子：</p>
<pre><code>objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
    $(CC) -c $(CFLAGS) $&lt; -o $@
</code></pre>
<p>上面的例子中，指明了我们的目标从$object中获取， %.o 表明要所有以 .o 结尾的目标，也就是 foo.o bar.o ，也就是变量 $object 集合的模式，而依赖模式<code>%.c</code> 则取模式<code>%.o</code>的 % ，也就是 foo bar ，并为其加下 .c 的后缀，于是，我们的依赖目标就是 foo.c bar.c 。而命令中的 <code>$&lt; </code> 和 <code>$@ </code>则是自动化变量，<code>$&lt;</code>表示第一个依赖文件， $@ 表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p>
<pre><code>foo.o : foo.c
    $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o : bar.c
    $(CC) -c $(CFLAGS) bar.c -o bar.o
</code></pre>
<h2 id="自动生成依赖性"><a class="header" href="#自动生成依赖性">自动生成依赖性</a></h2>
<p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件</p>
<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令:</p>
<pre><code>cc -M main.c
</code></pre>
<p>其输出是：</p>
<pre><code>main.o : main.c defs.h
</code></pre>
<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用 -MM 参数，不然， -M 参数会把一些标准库的头文件也包含进来。</p>
<p><code>gcc -M main.c</code>的输出是:</p>
<pre><code class="language-main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \">    /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \
    /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \
    /usr/include/bits/sched.h /usr/include/libio.h \
    /usr/include/_G_config.h /usr/include/wchar.h \
    /usr/include/bits/wchar.h /usr/include/gconv.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \
    /usr/include/bits/stdio_lim.h
</code></pre>
<p>gcc -MM main.c的输出则是:</p>
<p><code>main.o: main.c defs.h</code>
那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让 Makefile 自己依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 name.c 的文件都生成一个 name.d 的Makefile文件， .d 文件中就存放对应 .c 文件的依赖关系。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令"><a class="header" href="#命令">命令</a></h1>
<p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以 Tab 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p>
<p>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被 /bin/sh ——UNIX的标准Shell 解释执行的。除非你特别指定一个其它的Shell。Makefile中， # 是注释符，其后的本行字符都被注释。</p>
<h2 id="显示命令"><a class="header" href="#显示命令">显示命令</a></h2>
<p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 @ 字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:</p>
<p>@echo 正在编译XXX模块……
当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出:</p>
<p>echo 正在编译XXX模块……
正在编译XXX模块……</p>
<p><strong>如果make执行时，带入make参数 -n 或 –just-print ，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。而make参数 -s 或 –silent 或 –quiet 则是全面禁止命令的显示。</strong></p>
<h2 id="命令执行"><a class="header" href="#命令执行">命令执行</a></h2>
<p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。</p>
<h2 id="命令出错"><a class="header" href="#命令出错">命令出错</a></h2>
<p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<h2 id="嵌套执行make"><a class="header" href="#嵌套执行make">嵌套执行make</a></h2>
<p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了 -e 参数。</p>
<p>还有一个在“嵌套执行”中比较有用的参数， -w 或是 –print-directory 会在make的过程中输出一些信息，让你看到目前的工作目录。</p>
<h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”， “命令”或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 : 、 # 、 = 或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p>
<h2 id="变量的基础"><a class="header" href="#变量的基础">变量的基础</a></h2>
<p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上<code>$</code>符号，但最好用小括号 () 或是大括号 {} 把变量给包括起来。如果你要使用真实的<code>$</code>字符，那么你需要用<code>$$</code>来表示。</p>
<p>为了避免无限循环，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是 := 操作符，如：</p>
<pre><code>x := foo
y := $(x) bar
x := later
</code></pre>
<p>其等价于：</p>
<pre><code>y := foo bar
x := later
</code></pre>
<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p>
<pre><code>y := $(x) bar
x := foo
</code></pre>
<p>那么，y的值是“bar”，而不是“foo bar”。</p>
<h2 id="追加变量值"><a class="header" href="#追加变量值">追加变量值</a></h2>
<p>我们可以使用 += 操作符给变量追加值</p>
<h2 id="override-指令"><a class="header" href="#override-指令">override 指令</a></h2>
<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。
如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指令。其语法是:</p>
<pre><code class="language-override &lt;variable&gt;; = &lt;value&gt;;">
override &lt;variable&gt;; := &lt;value&gt;;
</code></pre>
<p>当然，你还可以追加:</p>
<pre><code>override &lt;variable&gt;; += &lt;more text&gt;;
</code></pre>
<p>对于多行的变量定义，我们用define指令，在define指令前，也同样可以使用override指令，如:</p>
<pre><code>override define foo
bar
endef
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了 CFLAGS 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p>
<h2 id="目标变量"><a class="header" href="#目标变量">目标变量</a></h2>
<p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如 $&lt; 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我也同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：</p>
<pre><code>&lt;target ...&gt; : &lt;variable-assignment&gt;;

&lt;target ...&gt; : overide &lt;variable-assignment&gt;
</code></pre>
<p><variable-assignment>;可以是前面讲过的各种赋值表达式，如 = 、 := 、 += 或是 ?= 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>
<pre><code>prog : CFLAGS = -g
prog : prog.o foo.o bar.o
    $(CC) $(CFLAGS) prog.o foo.o bar.o

prog.o : prog.c
    $(CC) $(CFLAGS) prog.c

foo.o : foo.c
    $(CC) $(CFLAGS) foo.c

bar.o : bar.c
    $(CC) $(CFLAGS) bar.c
</code></pre>
<p>在这个示例中，不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， $(CFLAGS) 的值都是 -g</p>
<h2 id="模式变量"><a class="header" href="#模式变量">模式变量</a></h2>
<p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个 % 的，所以，我们可以以如下方式给所有以 .o 结尾的目标定义目标变量：</p>
<p><code>%.o : CFLAGS = -O</code>
同样，模式变量的语法和“目标变量”一样：</p>
<pre><code>&lt;pattern ...&gt;; : &lt;variable-assignment&gt;;

&lt;pattern ...&gt;; : override &lt;variable-assignment&gt;;
</code></pre>
<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件判断"><a class="header" href="#条件判断">条件判断</a></h1>
<p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<p>下面的例子，判断 $(CC) 变量是否 gcc ，如果是的话，则使用GNU函数编译目标。</p>
<pre><code>libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
    $(CC) -o foo $(objects) $(libs_for_gcc)
else
    $(CC) -o foo $(objects) $(normal_libs)
endif
</code></pre>
<p>可见，在上面示例的这个规则中，目标 foo 可以根据变量 $(CC) 值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字： ifeq 、 else 和 endif 。 ifeq 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 else 表示条件表达式为假的情况。 endif 表示一个条件语句的结束，任何一个条件表达式都应该以 endif 结束。</p>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<p>条件表达式的语法为:</p>
<pre><code>&lt;conditional-directive&gt;
&lt;text-if-true&gt;
endif
</code></pre>
<p>以及:</p>
<pre><code>&lt;conditional-directive&gt;
&lt;text-if-true&gt;
else
&lt;text-if-false&gt;
endif
</code></pre>
<p>其中 <conditional-directive> 表示条件关键字，如 ifeq 。这个关键字有四个。</p>
<p>第一个是我们前面所见过的 ifeq</p>
<pre><code>ifeq (&lt;arg1&gt;, &lt;arg2&gt;)
ifeq '&lt;arg1&gt;' '&lt;arg2&gt;'
ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;
ifeq &quot;&lt;arg1&gt;&quot; '&lt;arg2&gt;'
ifeq '&lt;arg1&gt;' &quot;&lt;arg2&gt;&quot;
</code></pre>
<p>比较参数 arg1 和 arg2 的值是否相同。当然，参数中我们还可以使用make的函数。如:</p>
<pre><code>ifeq ($(strip $(foo)),)
&lt;text-if-empty&gt;
endif
</code></pre>
<p>这个示例中使用了 strip 函数，如果这个函数的返回值是空（Empty），那么 <text-if-empty> 就生效。</p>
<p>第二个条件关键字是 ifneq 。语法是：</p>
<pre><code>ifneq (&lt;arg1&gt;, &lt;arg2&gt;)
ifneq '&lt;arg1&gt;' '&lt;arg2&gt;'
ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;
ifneq &quot;&lt;arg1&gt;&quot; '&lt;arg2&gt;'
ifneq '&lt;arg1&gt;' &quot;&lt;arg2&gt;&quot;
</code></pre>
<p>其比较参数 arg1 和 arg2 的值是否相同，如果不同，则为真。和 ifeq 类似。</p>
<p>第三个条件关键字是 ifdef 。语法是：</p>
<p><code>ifdef &lt;variable-name&gt;</code>
如果变量 <variable-name> 的值非空，那到表达式为真。否则，表达式为假。当然， <variable-name> 同样可以是一个函数的返回值。注意， ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。</p>
<h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make 所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<p>函数的调用语法¶
函数调用，很像变量的使用，也是以 $ 来标识的，其语法如下：</p>
<p><code>$(&lt;function&gt; &lt;arguments&gt;)</code>
或是:</p>
<p><code>${&lt;function&gt; &lt;arguments&gt;}</code>
这里， <function> 就是函数名，make支持的函数不多。 <arguments> 为函数的参数，参数间以逗号 , 分隔，而函数名和参数之间以“空格”分隔。函数调用以<code>$</code>开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用<code>$(subst a,b,$(x))</code>这样的形式，而不是<code>$(subst a,b, ${x})</code>的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p>
<h2 id="字符串处理函数"><a class="header" href="#字符串处理函数">字符串处理函数</a></h2>
<ul>
<li>subst</li>
<li>patsubst</li>
<li>strip</li>
<li>findstring</li>
<li>filter</li>
<li>filter-out</li>
<li>sort</li>
<li>word</li>
<li>wordlist</li>
<li>words</li>
<li>firstword</li>
</ul>
<h2 id="文件名操作函数"><a class="header" href="#文件名操作函数">文件名操作函数</a></h2>
<ul>
<li>dir</li>
<li>notdir</li>
<li>suffix</li>
<li>basename</li>
<li>addsuffix</li>
<li>addprefix</li>
<li>join</li>
<li>foreach</li>
</ul>
<h2 id="if"><a class="header" href="#if">if</a></h2>
<p>很像ifeq</p>
<h2 id="call"><a class="header" href="#call">call</a></h2>
<p>类似自己定义函数</p>
<h2 id="origin"><a class="header" href="#origin">origin</a></h2>
<p>返回变量是从哪来的</p>
<h2 id="shell"><a class="header" href="#shell">shell</a></h2>
<p>执行shell命令</p>
<h2 id="控制make的函数"><a class="header" href="#控制make的函数">控制make的函数</a></h2>
<p>error,warning</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="make-的运行"><a class="header" href="#make-的运行">make 的运行</a></h1>
<p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h2 id="make的退出码"><a class="header" href="#make的退出码">make的退出码</a></h2>
<p>make命令执行后有三个退出码：</p>
<p>0
表示成功执行。</p>
<p>1
如果make运行时出现任何错误，其返回1。</p>
<p>2
如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</p>
<h2 id="指定makefile"><a class="header" href="#指定makefile">指定Makefile</a></h2>
<p>前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的 -f 或是 –file 参数（ –makefile 参数也行）。</p>
<h2 id="指定目标"><a class="header" href="#指定目标">指定目标</a></h2>
<p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）</p>
<p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<ul>
<li>all:这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li>
<li>clean:这个伪目标功能是删除所有被make创建的文件。</li>
<li>install:这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li>
<li>print:这个伪目标的功能是例出改变过的源文件。</li>
<li>tar:这个伪目标功能是把源程序打包备份。也就是一个tar文件。</li>
<li>dist:这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</li>
<li>TAGS:这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li>
<li>check和test:这两个伪目标一般用来测试makefile的流程。</li>
</ul>
<h2 id="参数"><a class="header" href="#参数">参数</a></h2>
<p>直接放<a href="https://seisman.github.io/how-to-write-makefile/invoke.html">链接</a></p>
<h1 id="其他"><a class="header" href="#其他">其他</a></h1>
<p>比较复杂，需要自己看文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实践makefile分析"><a class="header" href="#实践makefile分析">实践Makefile分析</a></h1>
<p>分析一些项目之中的Makefile，加深认识</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一个练手题目"><a class="header" href="#第一个练手题目">第一个练手题目</a></h1>
<p>NKU计网学院必修课编译原理大作业的makefile</p>
<p><a href="https://github.com/shm0214/2023NKUCS-Compilers-Lab">项目地址</a></p>
<h2 id="原始makefile"><a class="header" href="#原始makefile">原始makefile</a></h2>
<pre><code>SHELL := /bin/bash
SRC_PATH ?= src
INC_PATH += include
BUILD_PATH ?= build
TEST_PATH ?= test/level1-1
OBJ_PATH ?= $(BUILD_PATH)/obj
BINARY ?= $(BUILD_PATH)/compiler
SYSLIB_PATH ?= sysyruntimelibrary

INC = $(addprefix -I, $(INC_PATH))
SRC = $(shell find $(SRC_PATH)  -name &quot;*.cpp&quot;)
CFLAGS = -O2 -g -Wall -Werror $(INC)
FLEX ?= $(SRC_PATH)/lexer.l
LEXER ?= $(addsuffix .cpp, $(basename $(FLEX)))
BISON ?= $(SRC_PATH)/parser.y
PARSER ?= $(addsuffix .cpp, $(basename $(BISON)))
SRC += $(LEXER)
SRC += $(PARSER)
OBJ = $(SRC:$(SRC_PATH)/%.cpp=$(OBJ_PATH)/%.o)
PARSERH ?= $(INC_PATH)/$(addsuffix .h, $(notdir $(basename $(PARSER))))

TESTCASE = $(shell find $(TEST_PATH) -name &quot;*.sy&quot;)
TESTCASE_NUM = $(words $(TESTCASE))
LLVM_IR = $(addsuffix _std.ll, $(basename $(TESTCASE)))
GCC_ASM = $(addsuffix _std.s, $(basename $(TESTCASE)))
OUTPUT_LAB3 = $(addsuffix .toks, $(basename $(TESTCASE)))
OUTPUT_LAB4 = $(addsuffix .ast, $(basename $(TESTCASE)))
OUTPUT_LAB5 = $(addsuffix .ll, $(basename $(TESTCASE)))
OUTPUT_LAB6 = $(addsuffix .s, $(basename $(TESTCASE)))
OUTPUT_RES = $(addsuffix .res, $(basename $(TESTCASE)))
OUTPUT_BIN = $(addsuffix .bin, $(basename $(TESTCASE)))
OUTPUT_LOG = $(addsuffix .log, $(basename $(TESTCASE)))

.phony:all app run gdb testlab3 testlab4 testlab5 testlab6 testir test clean clean-all clean-test clean-app llvmir gccasm

all:app

$(LEXER):$(FLEX)
	@flex -o $@ $&lt;

$(PARSER):$(BISON)
	@bison -o $@ $&lt; --warnings=error=all --defines=$(PARSERH)

$(OBJ_PATH)/%.o:$(SRC_PATH)/%.cpp
	@mkdir -p $(OBJ_PATH)
	@g++ $(CFLAGS) -c -o $@ $&lt;

$(BINARY):$(OBJ)
	@g++ -O2 -g -o $@ $^

app:$(LEXER) $(PARSER) $(BINARY)

run:app
	@$(BINARY) -o example.s -S example.sy

gdb:app
	@gdb $(BINARY)

$(OBJ_PATH)/lexer.o:$(SRC_PATH)/lexer.cpp
	@mkdir -p $(OBJ_PATH)
	@g++ $(CFLAGS) -c -o $@ $&lt;

$(TEST_PATH)/%.toks:$(TEST_PATH)/%.sy
	@$(BINARY) $&lt; -o $@ -t

$(TEST_PATH)/%.ast:$(TEST_PATH)/%.sy
	@$(BINARY) $&lt; -o $@ -a

$(TEST_PATH)/%.ll:$(TEST_PATH)/%.sy
	@$(BINARY) $&lt; -o $@ -i

$(TEST_PATH)/%_std.ll:$(TEST_PATH)/%.sy
	@clang -x c $&lt; -S -m32 -emit-llvm -o $@

$(TEST_PATH)/%_std.s:$(TEST_PATH)/%.sy
	@arm-linux-gnueabihf-gcc -x c $&lt; -S -o $@

$(TEST_PATH)/%.s:$(TEST_PATH)/%.sy
	@timeout 5s $(BINARY) $&lt; -o $@ -S 2&gt;$(addsuffix .log, $(basename $@))
	@[ $$? != 0 ] &amp;&amp; echo &quot;\033[1;31mCOMPILE FAIL:\033[0m $(notdir $&lt;)&quot; || echo &quot;\033[1;32mCOMPILE SUCCESS:\033[0m $(notdir $&lt;)&quot;

llvmir:$(LLVM_IR)

gccasm:$(GCC_ASM)

testlab3:app $(OUTPUT_LAB3)

testlab4:app $(OUTPUT_LAB4)

testlab5:app $(OUTPUT_LAB5)

testlab6:app $(OUTPUT_LAB6)

.ONESHELL:
testir:app
	@success=0
	@for file in $(sort $(TESTCASE))
	do
		IR=$${file%.*}.ll
		LOG=$${file%.*}.log
		BIN=$${file%.*}.bin
		RES=$${file%.*}.res
		IN=$${file%.*}.in
		OUT=$${file%.*}.out
		FILE=$${file##*/}
		FILE=$${FILE%.*}
		timeout 5s $(BINARY) $${file} -o $${IR} -i 2&gt;$${LOG}
		RETURN_VALUE=$$?
		if [ $$RETURN_VALUE = 124 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mCompile Timeout\033[0m&quot;
			continue
		else if [ $$RETURN_VALUE != 0 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mCompile Error\033[0m&quot;
			continue
			fi
		fi
		clang -o $${BIN} $${IR} $(SYSLIB_PATH)/sylib.c &gt;&gt;$${LOG} 2&gt;&amp;1
		if [ $$? != 0 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mAssemble Error\033[0m&quot;
		else
			if [ -f &quot;$${IN}&quot; ]; then
				timeout 2s $${BIN} &lt;$${IN} &gt;$${RES} 2&gt;&gt;$${LOG}
			else
				timeout 2s $${BIN} &gt;$${RES} 2&gt;&gt;$${LOG}
			fi
			RETURN_VALUE=$$?
			FINAL=`tail -c 1 $${RES}`
			[ $${FINAL} ] &amp;&amp; echo -e &quot;\n$${RETURN_VALUE}&quot; &gt;&gt; $${RES} || echo &quot;$${RETURN_VALUE}&quot; &gt;&gt; $${RES}
			if [ &quot;$${RETURN_VALUE}&quot; = &quot;124&quot; ]; then
				echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mExecute Timeout\033[0m&quot;
			else if [ &quot;$${RETURN_VALUE}&quot; = &quot;127&quot; ]; then
				echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mExecute Error\033[0m&quot;
				else
					diff -Z $${RES} $${OUT} &gt;/dev/null 2&gt;&amp;1
					if [ $$? != 0 ]; then
						echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mWrong Answer\033[0m&quot;
					else
						success=$$((success + 1))
						echo -e &quot;\033[1;32mPASS:\033[0m $${FILE}&quot;
					fi
				fi
			fi
		fi
	done
	echo -e &quot;\033[1;33mTotal: $(TESTCASE_NUM)\t\033[1;32mAccept: $${success}\t\033[1;31mFail: $$(($(TESTCASE_NUM) - $${success}))\033[0m&quot;
	[ $(TESTCASE_NUM) = $${success} ] &amp;&amp; echo -e &quot;\033[5;32mAll Accepted. Congratulations!\033[0m&quot;
	:

.ONESHELL:
test:app
	@success=0
	@for file in $(sort $(TESTCASE))
	do
		ASM=$${file%.*}.s
		LOG=$${file%.*}.log
		BIN=$${file%.*}.bin
		RES=$${file%.*}.res
		IN=$${file%.*}.in
		OUT=$${file%.*}.out
		FILE=$${file##*/}
		FILE=$${FILE%.*}
		timeout 5s $(BINARY) $${file} -o $${ASM} -S 2&gt;$${LOG}
		RETURN_VALUE=$$?
		if [ $$RETURN_VALUE = 124 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mCompile Timeout\033[0m&quot;
			continue
		else if [ $$RETURN_VALUE != 0 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mCompile Error\033[0m&quot;
			continue
			fi
		fi
		arm-linux-gnueabihf-gcc -mcpu=cortex-a72 -o $${BIN} $${ASM} $(SYSLIB_PATH)/libsysy.a &gt;&gt;$${LOG} 2&gt;&amp;1
		if [ $$? != 0 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mAssemble Error\033[0m&quot;
		else
			if [ -f &quot;$${IN}&quot; ]; then
				timeout 2s qemu-arm -L /usr/arm-linux-gnueabihf $${BIN} &lt;$${IN} &gt;$${RES} 2&gt;&gt;$${LOG}
			else
				timeout 2s qemu-arm -L /usr/arm-linux-gnueabihf $${BIN} &gt;$${RES} 2&gt;&gt;$${LOG}
			fi
			RETURN_VALUE=$$?
			FINAL=`tail -c 1 $${RES}`
			[ $${FINAL} ] &amp;&amp; echo -e &quot;\n$${RETURN_VALUE}&quot; &gt;&gt; $${RES} || echo &quot;$${RETURN_VALUE}&quot; &gt;&gt; $${RES}
			if [ &quot;$${RETURN_VALUE}&quot; = &quot;124&quot; ]; then
				echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mExecute Timeout\033[0m&quot;
			else if [ &quot;$${RETURN_VALUE}&quot; = &quot;127&quot; ]; then
				echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mExecute Error\033[0m&quot;
				else
					diff -Z $${RES} $${OUT} &gt;/dev/null 2&gt;&amp;1
					if [ $$? != 0 ]; then
						echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mWrong Answer\033[0m&quot;
					else
						success=$$((success + 1))
						echo -e &quot;\033[1;32mPASS:\033[0m $${FILE}&quot;
					fi
				fi
			fi
		fi
	done
	echo -e &quot;\033[1;33mTotal: $(TESTCASE_NUM)\t\033[1;32mAccept: $${success}\t\033[1;31mFail: $$(($(TESTCASE_NUM) - $${success}))\033[0m&quot;
	[ $(TESTCASE_NUM) = $${success} ] &amp;&amp; echo -e &quot;\033[5;32mAll Accepted. Congratulations!\033[0m&quot;
	:

clean-app:
	@rm -rf $(BUILD_PATH) $(PARSER) $(LEXER) $(PARSERH)

clean-test:
	@rm -rf $(OUTPUT_LAB3) $(OUTPUT_LAB4) $(OUTPUT_LAB5) $(OUTPUT_LAB6) $(OUTPUT_LOG) $(OUTPUT_BIN) $(OUTPUT_RES) $(LLVM_IR) $(GCC_ASM) *.toks *.ast *.ll *.s *.out

clean-all:clean-test clean-app

clean:clean-all
</code></pre>
<h2 id="逐步分析"><a class="header" href="#逐步分析">逐步分析</a></h2>
<h3 id="定义变量"><a class="header" href="#定义变量">定义变量</a></h3>
<pre><code>SHELL := /bin/bash
SRC_PATH ?= src
INC_PATH += include
BUILD_PATH ?= build
TEST_PATH ?= test/level1-1
OBJ_PATH ?= $(BUILD_PATH)/obj
BINARY ?= $(BUILD_PATH)/compiler
SYSLIB_PATH ?= sysyruntimelibrary
</code></pre>
<p>其意义基本如下</p>
<ul>
<li>SHELL := /bin/bash：指定Make使用的Shell，而不是默认的/bin/sh。</li>
<li>SRC_PATH ?= src：源代码目录。</li>
<li>INC_PATH += include：头文件目录。</li>
<li>BUILD_PATH ?= build：最后生成的目录。</li>
<li>TEST_PATH ?= test/level1-1：测试用例目录。</li>
<li>OBJ_PATH ?= $(BUILD_PATH)/obj：目标文件目录。</li>
<li>BINARY ?= $(BUILD_PATH)/compiler：输出的二进制可执行文件。</li>
<li>SYSLIB_PATH ?= sysyruntimelibrary：系统运行库的路径。</li>
</ul>
<pre><code>INC = $(addprefix -I, $(INC_PATH))
SRC = $(shell find $(SRC_PATH)  -name &quot;*.cpp&quot;)
CFLAGS = -O2 -g -Wall -Werror $(INC)
FLEX ?= $(SRC_PATH)/lexer.l
LEXER ?= $(addsuffix .cpp, $(basename $(FLEX)))
BISON ?= $(SRC_PATH)/parser.y
PARSER ?= $(addsuffix .cpp, $(basename $(BISON)))
SRC += $(LEXER)
SRC += $(PARSER)
OBJ = $(SRC:$(SRC_PATH)/%.cpp=$(OBJ_PATH)/%.o)
PARSERH ?= $(INC_PATH)/$(addsuffix .h, $(notdir $(basename $(PARSER))))

</code></pre>
<ul>
<li><code>INC = $(addprefix -I, $(INC_PATH))</code>：给头文件加前缀，指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</li>
<li><code>SRC = $(shell find $(SRC_PATH) -name &quot;*.cpp&quot;)</code>：在源目录中查找所有源文件。</li>
<li><code>CFLAGS = -O2 -g -Wall -Werror $(INC)</code>：gcc编译器的标志。</li>
<li><code>FLEX ?= $(SRC_PATH)/lexer.l</code>：Flex输入文件。</li>
<li><code>LEXER ?= $(addsuffix .cpp, $(basename $(FLEX)))</code>：生成的词法分析器源文件。</li>
<li><code>BISON ?= $(SRC_PATH)/parser.y</code>：Bison输入文件。</li>
<li><code>PARSER ?= $(addsuffix .cpp, $(basename $(BISON)))</code>：生成的语法分析器源文件。</li>
<li><code>SRC += $(LEXER) $(PARSER)</code>：将词法分析器和语法分析器追加到源文件列表。</li>
<li><code>OBJ = $(SRC:$(SRC_PATH)/%.cpp=$(OBJ_PATH)/%.o)</code>：目标文件。</li>
<li><code>PARSERH ?= $(INC_PATH)/$(addsuffix .h, $(notdir $(basename $(PARSER))))</code>:生成的语法分析器头文件
这里最复杂的最后一句是这样的：
先取不是后缀的部分，然后去掉目录部分，再加上.h后缀，最后和目录拼起来。</li>
</ul>
<pre><code>TESTCASE = $(shell find $(TEST_PATH) -name &quot;*.sy&quot;)
TESTCASE_NUM = $(words $(TESTCASE))
LLVM_IR = $(addsuffix _std.ll, $(basename $(TESTCASE)))
GCC_ASM = $(addsuffix _std.s, $(basename $(TESTCASE)))
OUTPUT_LAB3 = $(addsuffix .toks, $(basename $(TESTCASE)))
OUTPUT_LAB4 = $(addsuffix .ast, $(basename $(TESTCASE)))
OUTPUT_LAB5 = $(addsuffix .ll, $(basename $(TESTCASE)))
OUTPUT_LAB6 = $(addsuffix .s, $(basename $(TESTCASE)))
OUTPUT_RES = $(addsuffix .res, $(basename $(TESTCASE)))
OUTPUT_BIN = $(addsuffix .bin, $(basename $(TESTCASE)))
OUTPUT_LOG = $(addsuffix .log, $(basename $(TESTCASE)))
</code></pre>
<ul>
<li><code>TESTCASE = $(shell find $(TEST_PATH) -name &quot;*.sy&quot;)</code>：查找所有测试用例。
后边是基于测试用例的各种输出文件的变量，有评分的LLVM和GCC还有各个实验自己的。</li>
</ul>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<pre><code>.phony:all app run gdb testlab3 testlab4 testlab5 testlab6 testir test clean clean-all clean-test clean-app llvmir gccasm

all:app

$(LEXER):$(FLEX)
	@flex -o $@ $&lt;

$(PARSER):$(BISON)
	@bison -o $@ $&lt; --warnings=error=all --defines=$(PARSERH)

$(OBJ_PATH)/%.o:$(SRC_PATH)/%.cpp
	@mkdir -p $(OBJ_PATH)
	@g++ $(CFLAGS) -c -o $@ $&lt;

$(BINARY):$(OBJ)
	@g++ -O2 -g -o $@ $^

app:$(LEXER) $(PARSER) $(BINARY)

run:app
	@$(BINARY) -o example.s -S example.sy

gdb:app
	@gdb $(BINARY)

$(OBJ_PATH)/lexer.o:$(SRC_PATH)/lexer.cpp
	@mkdir -p $(OBJ_PATH)
	@g++ $(CFLAGS) -c -o $@ $&lt;

$(TEST_PATH)/%.toks:$(TEST_PATH)/%.sy
	@$(BINARY) $&lt; -o $@ -t

$(TEST_PATH)/%.ast:$(TEST_PATH)/%.sy
	@$(BINARY) $&lt; -o $@ -a

$(TEST_PATH)/%.ll:$(TEST_PATH)/%.sy
	@$(BINARY) $&lt; -o $@ -i

$(TEST_PATH)/%_std.ll:$(TEST_PATH)/%.sy
	@clang -x c $&lt; -S -m32 -emit-llvm -o $@

$(TEST_PATH)/%_std.s:$(TEST_PATH)/%.sy
	@arm-linux-gnueabihf-gcc -x c $&lt; -S -o $@

$(TEST_PATH)/%.s:$(TEST_PATH)/%.sy
	@timeout 5s $(BINARY) $&lt; -o $@ -S 2&gt;$(addsuffix .log, $(basename $@))
	@[ $$? != 0 ] &amp;&amp; echo &quot;\033[1;31mCOMPILE FAIL:\033[0m $(notdir $&lt;)&quot; || echo &quot;\033[1;32mCOMPILE SUCCESS:\033[0m $(notdir $&lt;)&quot;

llvmir:$(LLVM_IR)

gccasm:$(GCC_ASM)

testlab3:app $(OUTPUT_LAB3)

testlab4:app $(OUTPUT_LAB4)

testlab5:app $(OUTPUT_LAB5)

testlab6:app $(OUTPUT_LAB6)
</code></pre>
<ul>
<li><code>.phony: all app run gdb testlab3 testlab4 testlab5 testlab6 testir test clean clean-all clean-test clean-app llvmir gccasm</code>：伪目标，这样所有的命令都要指定才会允许。</li>
<li><code>all: app</code>：默认目标是构建app。</li>
<li><code>app: $(LEXER) $(PARSER) $(BINARY)</code>：构建编译器应用程序。</li>
<li><code>run: app</code>：在样例输入（example.sy）上运行编译器。</li>
<li><code>gdb: app</code>：在编译的二进制文件上运行GDB。</li>
</ul>
<p>这里的自动化变量很重要，<code>$&lt;</code>是依赖的挨个的值，而<code>$@</code>是目标的挨个的值，举例</p>
<pre><code>$(TEST_PATH)/%_std.s:$(TEST_PATH)/%.sy
	@arm-linux-gnueabihf-gcc -x c $&lt; -S -o $@
</code></pre>
<p>这里就是把所有在测试目录底下每一个叫.sy的文件视为C语言(-x c)，然后编译成汇编(-S)，输出在这个目录底下同一个名字但是叫_std.s的汇编文件(-o)</p>
<h2 id="函数-1"><a class="header" href="#函数-1">函数</a></h2>
<pre><code>.ONESHELL:
testir:app
	@success=0
	@for file in $(sort $(TESTCASE))
	do
		IR=$${file%.*}.ll
		LOG=$${file%.*}.log
		BIN=$${file%.*}.bin
		RES=$${file%.*}.res
		IN=$${file%.*}.in
		OUT=$${file%.*}.out
		FILE=$${file##*/}
		FILE=$${FILE%.*}
		timeout 5s $(BINARY) $${file} -o $${IR} -i 2&gt;$${LOG}
		RETURN_VALUE=$$?
		if [ $$RETURN_VALUE = 124 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mCompile Timeout\033[0m&quot;
			continue
		else if [ $$RETURN_VALUE != 0 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mCompile Error\033[0m&quot;
			continue
			fi
		fi
		clang -o $${BIN} $${IR} $(SYSLIB_PATH)/sylib.c &gt;&gt;$${LOG} 2&gt;&amp;1
		if [ $$? != 0 ]; then
			echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mAssemble Error\033[0m&quot;
		else
			if [ -f &quot;$${IN}&quot; ]; then
				timeout 2s $${BIN} &lt;$${IN} &gt;$${RES} 2&gt;&gt;$${LOG}
			else
				timeout 2s $${BIN} &gt;$${RES} 2&gt;&gt;$${LOG}
			fi
			RETURN_VALUE=$$?
			FINAL=`tail -c 1 $${RES}`
			[ $${FINAL} ] &amp;&amp; echo -e &quot;\n$${RETURN_VALUE}&quot; &gt;&gt; $${RES} || echo &quot;$${RETURN_VALUE}&quot; &gt;&gt; $${RES}
			if [ &quot;$${RETURN_VALUE}&quot; = &quot;124&quot; ]; then
				echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mExecute Timeout\033[0m&quot;
			else if [ &quot;$${RETURN_VALUE}&quot; = &quot;127&quot; ]; then
				echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mExecute Error\033[0m&quot;
				else
					diff -Z $${RES} $${OUT} &gt;/dev/null 2&gt;&amp;1
					if [ $$? != 0 ]; then
						echo -e &quot;\033[1;31mFAIL:\033[0m $${FILE}\t\033[1;31mWrong Answer\033[0m&quot;
					else
						success=$$((success + 1))
						echo -e &quot;\033[1;32mPASS:\033[0m $${FILE}&quot;
					fi
				fi
			fi
		fi
	done
	echo -e &quot;\033[1;33mTotal: $(TESTCASE_NUM)\t\033[1;32mAccept: $${success}\t\033[1;31mFail: $$(($(TESTCASE_NUM) - $${success}))\033[0m&quot;
	[ $(TESTCASE_NUM) = $${success} ] &amp;&amp; echo -e &quot;\033[5;32mAll Accepted. Congratulations!\033[0m&quot;
	:
</code></pre>
<blockquote>
<p>借助一下chatgpt</p>
</blockquote>
<ol>
<li>
<p><strong><code>.ONESHELL:</code>：</strong></p>
<ul>
<li>这是一个Makefile特殊的标记，它告诉Make工具在一个Shell中执行整个规则的命令。这样可以确保整个规则中的命令共享相同的Shell环境。</li>
</ul>
</li>
<li>
<p><strong><code>testir:app</code>：</strong></p>
<ul>
<li>这定义了一个名为 <code>testir</code> 的目标，它依赖于 <code>app</code>。也就是说，在执行 <code>testir</code> 之前，确保 <code>app</code> 已经构建。</li>
</ul>
</li>
<li>
<p><strong>命令部分：</strong></p>
<ul>
<li>
<p>代码段以 <code>@success=0</code> 开始，初始化一个计数器 <code>success</code> 为 0。</p>
</li>
<li>
<p>通过循环遍历所有测试用例文件 <code>$(TESTCASE)</code>：</p>
<ul>
<li>
<p><code>IR=$${file%.*}.ll</code>：定义 <code>IR</code> 变量，表示将测试用例文件的扩展名 <code>.sy</code> 替换为 <code>.ll</code>。</p>
</li>
<li>
<p><code>LOG=$${file%.*}.log</code>：定义 <code>LOG</code> 变量，表示日志文件。</p>
</li>
<li>
<p><code>BIN=$${file%.*}.bin</code>：定义 <code>BIN</code> 变量，表示生成的二进制文件。</p>
</li>
<li>
<p><code>RES=$${file%.*}.res</code>：定义 <code>RES</code> 变量，表示执行结果输出文件。</p>
</li>
<li>
<p><code>IN=$${file%.*}.in</code>：定义 <code>IN</code> 变量，表示输入文件。</p>
</li>
<li>
<p><code>OUT=$${file%.*}.out</code>：定义 <code>OUT</code> 变量，表示期望输出文件。</p>
</li>
<li>
<p><code>FILE=$${file##*/}</code>：提取测试用例文件的纯文件名，去掉路径部分。</p>
</li>
<li>
<p><code>FILE=$${FILE%.*}</code>：去掉文件名的扩展名，得到测试用例的基本名。</p>
</li>
<li>
<p><code>timeout 5s $(BINARY) $${file} -o $${IR} -i 2&gt;$${LOG}</code>：运行编译器，生成 LLVM IR。<code>-o $${IR}</code> 指定输出文件，<code>-i</code> 表示生成 LLVM IR。</p>
</li>
<li>
<p><code>RETURN_VALUE=$$?</code>：获取上一条命令的返回值。</p>
</li>
<li>
<p>条件判断，根据返回值的不同情况输出相应的信息，例如编译超时、编译错误等。</p>
</li>
<li>
<p><code>clang -o $${BIN} $${IR} $(SYSLIB_PATH)/sylib.c &gt;&gt;$${LOG} 2&gt;&amp;1</code>：使用 <code>clang</code> 将 LLVM IR 编译成二进制文件。</p>
</li>
<li>
<p>进行测试执行，检查执行结果，并根据情况输出相应的信息。</p>
</li>
<li>
<p>最后统计成功和失败的测试数目。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>echo -e &quot;\033[1;33mTotal: $(TESTCASE_NUM)\t\033[1;32mAccept: $${success}\t\033[1;31mFail: $$(($(TESTCASE_NUM) - $${success}))\033[0m&quot;</code>：</strong></p>
<ul>
<li>输出测试总数、通过数、失败数的统计信息。</li>
</ul>
</li>
<li>
<p><strong><code>[ $(TESTCASE_NUM) = $${success} ] &amp;&amp; echo -e &quot;\033[5;32mAll Accepted. Congratulations!\033[0m&quot;</code>：</strong></p>
<ul>
<li>如果所有测试都通过，则输出祝贺消息。</li>
</ul>
</li>
<li>
<p><strong><code>:</code>：</strong></p>
<ul>
<li>这是一个单独的冒号，表示一个空操作。在这里，它用于确保目标 <code>testir</code> 总是被认为是 “up to date”，即不需要重新构建。</li>
</ul>
</li>
</ol>
<h2 id="清除"><a class="header" href="#清除">清除</a></h2>
<pre><code>
clean-app:
	@rm -rf $(BUILD_PATH) $(PARSER) $(LEXER) $(PARSERH)

clean-test:
	@rm -rf $(OUTPUT_LAB3) $(OUTPUT_LAB4) $(OUTPUT_LAB5) $(OUTPUT_LAB6) $(OUTPUT_LOG) $(OUTPUT_BIN) $(OUTPUT_RES) $(LLVM_IR) $(GCC_ASM) *.toks *.ast *.ll *.s *.out

clean-all:clean-test clean-app

clean:clean-all
</code></pre>
<p>清理对应的目录，注意clean也依赖了多个伪目标</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="稍微复杂一些的makefile"><a class="header" href="#稍微复杂一些的makefile">稍微复杂一些的makefile</a></h1>
<p>2017年及以前的清华大学操作系统实验ucore的makefile</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="南开大学操作系统实验的makefile"><a class="header" href="#南开大学操作系统实验的makefile">南开大学操作系统实验的makefile</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非常复杂的内容"><a class="header" href="#非常复杂的内容">非常复杂的内容</a></h1>
<p>optee的makefile</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
